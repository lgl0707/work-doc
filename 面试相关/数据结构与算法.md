1、冒泡排序

2、快速排序

3、归并排序

4、桶排序



1、数组与链表

链表的一些题目：

- 链表是否有环，输出环的入口
- 链表中倒数第K个节点
- 链表的中间节点
- 两个链表，找出它们的第一个公共节点
- 两个有序链表合并

2、二分查找

首先，二分查找依赖的是顺序表结构，简单点说就是数组。

其次，二分查找针对的是有序数据

再次，数据量太小不适合二分查找。

最后，数据量太大也不适合二分查找。

3、栈和队列

栈是一种“操作受限”的线性表，只允许在一端插入和删除数据。

应用：

- 函数调用栈、
- 编译器如何利用栈来实现表达式求值。
- 栈在括号匹配中的应用

队列：操作受限的线性表数据结构。

4、哈希表

 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。

散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

5、跳表

只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫做跳表.

其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。

当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。

不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。

6、红黑树

- 根节点是黑色的；

- 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；

- 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；

- 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；

红黑树是一种平衡二叉查找树。它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。

红黑树的高度近似 log2n，所以它是近似平衡，插入、删除、查找操作的时间复杂度都是 O(logn)。

因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡是用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，如果自己写代码实现，难度会有些高，这个时候，我们其实更倾向用跳表来替代它。

7、B树



8、堆和堆排序

- 堆是一个完全二叉树；

- 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

应用：

- 堆的应用一：优先级队列
- 利用堆求 Top K
- 利用堆求中位数

9、

- 散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。

- 跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。

- 红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。

一些代码实现：

string类

memmov()

memcpy()

strcpy()和strncpy()

atoi()

```c++
#include <stdio.h>
#include <string>

//strcpy
char *strcpy(char *dest, const char *src)
{
    assert(dest != NULL && src != NULL);
    char *temp = dest;
    while(*src != '\0')
        *dest++ = *src++;
    *dest = '\0';
    return temp;
}

//memcpy
void *memcpy(void *dest, const void *src, size_t n)
{
    assert(dest != NULL && src != NULL);
    char *temp = (char*)dest;
    while(n--)
        *temp++ = *src++;
    return dest;
}

//atoi
int matoi(std::string str)
{
    int len = str.length();
    int i = 0;//循环用
    int digit = 0;//位数
    int flag = 0;//判断正负
    long ret;//结果
    //先去掉前面的空格
    for(;i < len; i++)
    {
        if(str[i] != ' ')
        {
            break;
        }
    }
    //判断正负
    if(str[i] == '-')
    {
        flag = 0;
    }else if(str[i] == '+')
    {
        flag = 1;
    }
    else if(str[i] > '0' && str[i] < '9')
    {
        digit = 1;
        ret = str[i] - '0';
    }
    i++;
    //转化数字
    for(;i < len; i++)
    {
        if(digit > 10)
        {
            break;
        }
        if(str[i] < '0' || str[i] > '9')
        {
            break;
        }
        ret = ret * 10 + str[i] - '0';
        digit++;
    }
    if(ret > INT_MAX && flag)
    {
        return INT_MAX;//INT_MAX为2的31次方减1
    }
    if(ret*(-1) < INT_MIN && !flag)
    {
        return INT_MIN;
    }

    return flag?ret:ret*(-1);
}
```